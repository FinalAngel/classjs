
The following methods can be used as soon as a new instance has been created:


Class.extend(object)
=====================

(object) - The class object will be passed through Class.$extend({}); to create a new class with all the methods
described underneath.

Create a new class::

	var Animal = Class.$extend({
		initialize: function (name, age) {
			this.name = name;
			this.age = age;
		},
		eat: function () {
			alert(this.name, + ' is eating now.');
		}
	});

Extend the class:

	var Cat = Animal.$extend({
		die: function () {
			alert(this.name + ' died at age ' + this.age);
		}
	});

	new Cat('Sora', 5);
	Cat.die();

Class.setOptions(object)
========================

``(returns object)`` - Creates a new instance of the class by bypassing the constructor and assigning the attributes from the given object.
This is useful if you want to attach methods to an object recieved from a JSON object::

	var MyClass = Class.$extend({
	    __init__ : function() { alert('called'); },
	    toString() : function() {
	        return this.value;
	    })
	});
	var obj = MyClass.$withData({value: 42});
	alert(obj.toString());

The example above will alert "42" only. So the constructor is not called but you


Class.noConflict()
==================

``(returns object)`` - Removes the Class object from the window object and restores what was there before Classy was loaded.
It then returns the class object from the function. This makes it possible to use multiple versions of Classy
side by side or in combination with other libraries that also define an object with that name.

Sample usuage::

	(function (Classy) {
	    // use Classy here without any conflict.
	})(Class.noConflict());


Class.super()
=============

``(returns object)`` - When called from within a Classy function this invokes the parent function of the same name.
The arguments are forwarded directly. Check out the examples above for how that works.


Class.version()
===============

``(returns string)`` - Returns the current Classy version as a string.